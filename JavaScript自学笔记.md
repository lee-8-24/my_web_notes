# JavaScript系统学习



ECMAScript标准

Chrome --v8引擎

FireFox--SpideMonkey

ECMAScript==JavaScript

一般JavaScript分

ECMAScript  

DOM 

BOM

> 解释型语言
>
> 类似C和Java
>
> 动态语言
>
> 基于原型的**面向对象**

JS代码需要写道<script>标签中

**:fire: 位置**

- 可以嵌套写，但是不建议
- 可以写到外部文件中在不同页面中同时引用，利用浏览器的缓存机制， 这是推荐使用的方法

> script标签一旦用于引入外部文件就不能再写代码了，即使写了浏览器也会忽略
>
> 如果需要，则要重新写一个

外部调用

```html
<script src="../js/TEST_3_18.js"></script>
```

嵌套写==写在按钮中，写在超链接中==：

```html
 <!-- 将js编写到标签的onclick属性中，点击才会执行 -->

        <button onclick="alert('点我干嘛');">点我一下</button>
        <!--写在超链接href属性中，点超链接执行  -->
        <a href="javascript:alert('让你点你就点!');">点我</a>
       <!-- 点了没反映 -->
        <a href="javascript:;">点我</a>
```



**:fire: 输出语句**

```html
        <script>
            // 控制浏览器发出警告
            alert("这时我的第一行JS代码")

        </script>
```

```html
            // 控制浏览器发出警告
            // alert("这时我的第一行JS代码")
            //  document.write()body中输出内容
            // document.write("你看我出不出来")
            // console.log("在哪里")在控制台输出(开发人员才知道)
            alert("这时我的第一行JS代码");
            document.write("你看我出不出来");
            console.log("在哪里");
```

**:fire: 语法**

严格区分大小写

每一句以分号结尾

JS会忽略空格和换行

**:fire: 常量和变量**

变量表示常量

先声明变量

再变量赋值；声明赋值同时进行

```html
var x;

x=2312321321;
```

六种类型

字符串 String--引号引起来，双引号单引号都行

数值 	Number--最大.7976....后面308位Number.MAX_VALUE  如果超过则Infinity

布尔值 Boolean

空值 Null

未定义 Undefined

对象 Object

> 可以用\来转义
>
> alert 阻塞函数

.....

:fire: **引用数据类型**

obj

```js
var obj=new Object()
obj.age=14;
obj.grade=100;
alert(obj.name);
```

对象是保存再堆中的，每创建一个对象，就会在堆内存中开辟出一个新的空间，变量保存的是对象内存地址。

> 看到50了

```
var obj={};
```

上面语句用来创建一个对象，同时指定属性在大括号里添加

对象属性名可以加引号也可以不加，建议不加

属性名和属性值是一组一组的量，如果一个属性之后无属性；类似于字典



:fire: **函数**

函数也是对象，函数里可以封装一些功能;可以保存一些代码

创建一个函数对象

var fun= new Function()

使用typeof检查一个函数对象时，会返回function

**调用函数**

函数对象+()



更常用：

function 函数名(形参1，形参2...形参N){语句}



使用函数表达式来创建一个函数

var 函数名=function([形参1，2.。。。]){语句};

> 返回值可以是任意类型，也可是对象



==看到55==

**立即执行函数**

套一个括号表示是一个整体，可以用匿名函数

**函数对象**

```javascript
(function(){
	alert("我是一个匿名函数");
})();
```

:fire: **对象**

向对象中添加属性

对象的属性值可以是任何数据类型，可以为函数嘛？

```javascript
obj.sayname=function(){

	alert("666");

}
```

函数也可以为对象的属性，如果一个函数作为一个对象的属性保存，那么我们称这个韩式是对象的方法，调用这个函数就说调用对象的方法。

对象函数的定义2

```
var car={
    name:"tesila",
    age:"2",
    run:function(){
        document.write("RUN FAST!");
    }
}
```



**枚举对象中属性**

```
            for(var a in car){
                alert(a);
            }
```

for ..in 语句可以把对象中的每一个属性都遍历了每执行一次a就为属性名

```
                document.write(car[a]);
```

**取出属性值**



:fire: **作用域**

1. 全局作用域
   1. 直接编写在script标签中的JS代码，都在全局作用域
   2. 在页面打开时创建，关闭时销毁
   3. 全局作用域有一个全局对象window，可以直接适用
      1. 代表一个浏览器的窗口，由浏览器创建时直接使用
   4. 全局作用域中：
      1. 创建的变量会作为window对象的属性保存
      2. 都是window对象的变量或者方法(函数也就是方法)
2. 函数作用域
   1. 调用函数时创建作用域，执行完毕后，作用域销毁
   2. 调用一次就会创建一个新的函数作用域，他们之间是相互独立的，
   3. 函数作用域钟可以访问到全局变量
   4. 全局不能访问局部
   5. 当在函数作用域操作一个变量，它会先在自身作用域寻找，如果有就直接使用，如果没有就向上一级作用域中寻找，直到找到全局作用域，如果全局作用域中依然没有找到，报错；
   6. 访问全局也可以用window
   7. 函数中不用var声明都为全局

- 变量的声明`var a`在所有语句之前执行，但是赋值却不行
- 函数的声明创建的函数function 函数(){}会优先执行，可以在函数声明之前执行；函数表达式不会被提前；



**:fire:Debug**

设置断点

单步调试，可以监控变量值



:fire: **this**

解析器在调用函数每次都会向函数内部传递一个隐含参数

这个隐含参数 this

this指向的是函数执行的上下文对象，根据函数**调用方式**不同，this会指向不同的对象。

- 以函数形式调用，this永远指window
- 以方法得形式调用，this指的就是调用方法得对象

:fire: **批量创建对象**

大量重复性代码。提取到函数里

**使用工厂地方法创建对象**

定义函数来创建对象

```javascript
        function createperson(na, ag, gen) {
                var obj = new Object();
                obj.name = na;
                obj.age = ag;
                obj.gender = gen;
                return obj;
            }
```



:fire: **toString**

当我们直接在页面中打印一个对象时，事实上是输出对象的toString()方法的返回值

原型的原型中，如果我们希望在输出对象不输出



:fire: **原型(有点类似于父类的感觉，类与继承)**

```javascript
var mc = new Myclass();
console.log(mc._proto_.proto_.hasOwnProperty);
```

- 将函数i当以在全局作用域中污染了全局作用域的命名空间；
- 而且定义在全局作用域中也很不安全，所以引入了原型。
- 我们所创建的每一个函数，解析器都会想函数添加一个属性prototype；这个属性对应一个对象，这个对象就是我们所谓的原型对象。
- 如果函数作为普通函数调用，prototype没有任何作用；当函数通过构造函数调用，它所创建的对象中都会有一个隐含的属性，指向该函数的原型对象，我们可以通过_proto_来访问属性。
- 原型对象就相当于 一个公共的区域，所有同一个类的实例都可以访问到这个原型对象。
- 当我们访问对象的一个属性或者方法时，他会现在对象自身中寻找，如果没有，会在原型对象中寻找。
- 以后创建构造函数时，可以将这些对象所有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个独享具有这些属性和方法了。
- 使用in检查对象是否有某个属性，如果对象中没有但是原型中有，也会返回true
- 可以使用对象中的hasOwnProperty()函数只有对象自身中有时才会返回true
- 原型对象中还是有一个原型，当我们使用一个对象的属性或者方法时，现在自身中寻找，自身没有去原型中，原型中没有再去原型的原型中
- 直到找到Object对象的原型，Object对象的原型无原型，如果还未找到就undefined



:fire: **垃圾回收**

垃圾回收机制来处理程序运行过程中产生的垃圾

当一个对象没有任何变量或者属性对它进行引用，此时无法操作该对象。之中为垃圾，会占用大量的内存空间。

JS中有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁。

我要要做的是把不用的对象设为null



:fire: **数组对象(内建对象，宿主对象)**

数组(Array)；数组也是对象它我们普通对象功能类似，不同是普通对象时使用字符串为属性名。而数组时使用数字来作为属性索引。

数组存储性能比普通对象好。

创建数组对象

```javascript
var arr =new Array();
```

和C语言一样

数组.length获得数组长度；(连续的数组)

不连续的数组为最大数组索引+1

==尽量不要创建非连续数组==

修改的length大于原长度会，多出部分会空出

修改的length小于原长度，多的部分会删除

```javascript
arr[arr.length]=70;
```

新加数组

==看到71了==